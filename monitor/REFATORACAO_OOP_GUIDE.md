# Guia de Refatora√ß√£o OOP - Sistema AmFi

## üìã **VIS√ÉO GERAL**

Este documento detalha o processo de refatora√ß√£o do sistema AmFi de monitoramento funcional para arquitetura orientada a objetos (OOP), com foco na implementa√ß√£o bem-sucedida do Monitor de Inadimpl√™ncia.

---

## üéØ **OBJETIVOS DA REFATORA√á√ÉO**

### **Principais Metas:**
1. **Eliminar redund√¢ncias** entre monitores
2. **Padronizar valida√ß√µes** e tratamento de erros
3. **Facilitar manuten√ß√£o** e extensibilidade
4. **Preservar funcionalidade cr√≠tica** (enriquecimento progressivo)
5. **Garantir compatibilidade 100%** com sistema original

### **Benef√≠cios Alcan√ßados:**
- ‚úÖ **C√≥digo mais limpo** e organizado
- ‚úÖ **Reutiliza√ß√£o** de componentes
- ‚úÖ **Valida√ß√£o centralizada** via BaseMonitor
- ‚úÖ **Padr√£o Template Method** implementado
- ‚úÖ **Facilidade de teste** e debugging

---

## üèóÔ∏è **ARQUITETURA OOP IMPLEMENTADA**

### **1. Classe Base: `BaseMonitor`**
```python
class BaseMonitor(ABC):
    """Classe base para todos os monitores AmFi."""
    
    def __init__(self, monitor_id: str, config: Dict[str, Any]):
        self.monitor_id = monitor_id
        self.config = config
    
    @abstractmethod
    def is_active(self) -> bool:
        """Verifica se o monitor est√° ativo."""
        pass
    
    @abstractmethod 
    def get_required_columns(self) -> List[str]:
        """Retorna colunas obrigat√≥rias."""
        pass
    
    @abstractmethod
    def calculate(self, pool_csv: pd.DataFrame, carteira_xlsx: pd.DataFrame) -> Dict[str, Any]:
        """L√≥gica principal de c√°lculo."""
        pass
```

### **2. Classe Espec√≠fica: `DelinquencyMonitor`**
```python
class DelinquencyMonitor(BaseMonitor):
    """Monitor de inadimpl√™ncia com arquitetura OOP."""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(monitor_id="inadimplencia", config=config)
        self._delinquency_monitors = self._find_delinquency_monitors()
        self._pdd_config = self._find_pdd_config()
    
    def calculate(self, pool_csv: pd.DataFrame, carteira_xlsx: pd.DataFrame) -> Dict[str, Any]:
        # 1. Enriquecimento progressivo
        self._enrich_dataframe_progressively(carteira_xlsx)
        
        # 2. C√°lculos espec√≠ficos
        resultados_janelas = self._calculate_delinquency_windows(pool_xlsx, pl_pool)
        matriz_atrasos = self._generate_detailed_matrix(pool_xlsx)
        aging_analysis = self._generate_aging_analysis(pool_xlsx)
        
        # 3. Consolida√ß√£o
        return resultado_consolidado
```

---

## üîÑ **PADR√ÉO TEMPLATE METHOD**

### **Fluxo Padronizado:**
```python
def run_monitoring(self, pool_csv: pd.DataFrame, carteira_xlsx: pd.DataFrame) -> Dict[str, Any]:
    """Template Method - fluxo padronizado para todos os monitores."""
    
    # 1. Valida√ß√£o (implementa√ß√£o espec√≠fica)
    if not self.validate_data(pool_csv, carteira_xlsx):
        return erro_padronizado
    
    # 2. C√°lculo (implementa√ß√£o espec√≠fica)
    resultado_calculo = self.calculate(pool_csv, carteira_xlsx)
    
    # 3. Formata√ß√£o (padr√£o base)
    return self._format_result(resultado_calculo)
```

### **Vantagens:**
- ‚úÖ **Fluxo consistente** entre todos os monitores
- ‚úÖ **Valida√ß√£o padronizada** mas customiz√°vel
- ‚úÖ **Tratamento de erro** unificado
- ‚úÖ **Flexibilidade** para l√≥gica espec√≠fica

---

## üîß **IMPLEMENTA√á√ÉO DO ENRIQUECIMENTO PROGRESSIVO**

### **Conceito Cr√≠tico:**
O enriquecimento progressivo modifica o DataFrame `carteira_xlsx` **IN-PLACE**, adicionando campos calculados que s√£o reutilizados por monitores subsequentes.

### **Implementa√ß√£o:**
```python
def _enrich_dataframe_progressively(self, carteira_xlsx: pd.DataFrame) -> None:
    """Enriquece DataFrame global com campos calculados."""
    
    # 1. Adicionar dias_atraso (se n√£o existir)
    if 'dias_atraso' not in carteira_xlsx.columns:
        carteira_xlsx['dias_atraso'] = self._calculate_days_overdue(carteira_xlsx)
        print(f"‚úÖ ENRIQUECIMENTO: Campo 'dias_atraso' adicionado")
    
    # 2. Adicionar grupo_de_risco (se n√£o existir)
    if 'grupo_de_risco' not in carteira_xlsx.columns:
        if self._pdd_config:
            carteira_xlsx['grupo_de_risco'] = self._classify_risk_groups(
                carteira_xlsx['dias_atraso'], self._pdd_config
            )
            print(f"‚úÖ ENRIQUECIMENTO: Campo 'grupo_de_risco' adicionado")
```

### **Benef√≠cios:**
- ‚úÖ **Performance**: C√°lculos feitos uma √∫nica vez
- ‚úÖ **Consist√™ncia**: √önica fonte de verdade
- ‚úÖ **Reutiliza√ß√£o**: Outros monitores usam campos existentes
- ‚úÖ **Auditoria**: Campos persistem na mem√≥ria

---

## üìä **CONFIGURA√á√ÉO E DEPEND√äNCIAS**

### **Estrutura de Configura√ß√£o:**
```json
{
  "pool_id": "AFA Pool #1",
  "provisoes_pdd": {
    "grupos_risco": {
      "AA": {"atraso_max_dias": 0, "provisao_pct": 0.000},
      "A": {"atraso_max_dias": 15, "provisao_pct": 0.005},
      "B": {"atraso_max_dias": 30, "provisao_pct": 0.010}
    }
  },
  "monitoramentos_ativos": [
    {
      "id": "inadimplencia_30d",
      "tipo": "inadimplencia",
      "ativo": true,
      "limites": {"prazo_dias": 30, "limite": 0.04}
    }
  ]
}
```

### **Leitura de Configura√ß√£o:**
```python
def _find_pdd_config(self) -> Optional[Dict[str, Any]]:
    """Busca configura√ß√£o PDD no pool JSON."""
    pdd_config = self.config.get('provisoes_pdd', {}).get('grupos_risco', {})
    
    if pdd_config:
        return {'grupos_risco': pdd_config}
    
    return None
```

---

## üß™ **ESTRAT√âGIA DE TESTES**

### **Teste de Compatibilidade:**
```python
def test_single_pool(pool_name: str, dados: Dict[str, Any]) -> bool:
    """Testa compatibilidade entre original e OOP."""
    
    # Executar monitor original
    resultado_original = original_run(pool_csv, xlsx_original, pool_config)
    
    # Executar monitor OOP
    resultado_oop = oop_run(pool_csv, xlsx_oop, pool_config)
    
    # Comparar resultados campo a campo
    return compare_results(resultado_original, resultado_oop, pool_name)
```

### **Valida√ß√µes Cr√≠ticas:**
1. **Enriquecimento Progressivo**: Campos adicionados corretamente
2. **Janelas de Inadimpl√™ncia**: Resultados numericamente id√™nticos
3. **Aging Analysis**: Todas as faixas geradas
4. **Matriz Detalhada**: Consolida√ß√µes corretas
5. **Precis√£o Num√©rica**: Valores monet√°rios consistentes

---

## üîç **DEBUGGING E TROUBLESHOOTING**

### **Problemas Comuns:**

#### **1. Configura√ß√£o PDD Incorreta**
```python
# ‚ùå ERRO: Busca em local incorreto
pdd_config = self._pdd_config.get('grupos_risco', [])

# ‚úÖ CORRETO: Busca na estrutura correta
pdd_config = self.config.get('provisoes_pdd', {}).get('grupos_risco', {})
```

#### **2. Aging Analysis Incompleta**
```python
# ‚ùå ERRO: Apenas faixa 'adimplente' gerada
# Causa: Configura√ß√£o PDD n√£o encontrada

# ‚úÖ CORRE√á√ÉO: Verificar estrutura do JSON
if not pdd_config:
    return faixas_padrao  # Fallback
```

#### **3. Precis√£o de Floating Point**
```python
# ‚ùå ERRO: 2494304.5300000003
valor_sem_round = float(soma_valores)

# ‚úÖ CORRE√á√ÉO: Usar round consistente
valor_correto = round(float(soma_valores), 2)
```

### **Debugging Tools:**
```python
# Logging detalhado
print(f"üîÑ ENRIQUECIMENTO PROGRESSIVO: Iniciando...")
print(f"‚úÖ Campo 'dias_atraso': {len(carteira_xlsx)} registros processados")
print(f"üéØ Configura√ß√£o PDD: {len(pdd_config)} grupos encontrados")

# Valida√ß√£o de dados
assert 'dias_atraso' in carteira_xlsx.columns, "Campo dias_atraso n√£o foi adicionado"
assert carteira_xlsx['dias_atraso'].dtype == 'int64', "Tipo incorreto para dias_atraso"
```

---

## üöÄ **PADR√ÉO PARA NOVOS MONITORES**

### **1. Criar Classe Espec√≠fica:**
```python
class NovoMonitor(BaseMonitor):
    """Monitor espec√≠fico seguindo padr√£o OOP."""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(monitor_id="novo_monitor", config=config)
        self._config_especifica = self._load_specific_config()
    
    def is_active(self) -> bool:
        """Verifica√ß√£o espec√≠fica de ativa√ß√£o."""
        return self._config_especifica is not None
    
    def get_required_columns(self) -> List[str]:
        """Colunas obrigat√≥rias espec√≠ficas."""
        return ['coluna1', 'coluna2', 'coluna3']
    
    def calculate(self, pool_csv: pd.DataFrame, carteira_xlsx: pd.DataFrame) -> Dict[str, Any]:
        """L√≥gica espec√≠fica de c√°lculo."""
        # Implementa√ß√£o espec√≠fica
        pass
```

### **2. Implementar Interface de Compatibilidade:**
```python
def run_novo_monitoring(
    pool_data_csv: pd.DataFrame,
    carteira_xlsx: pd.DataFrame,
    config: Dict[str, Any]
) -> Dict[str, Any]:
    """Interface de compatibilidade."""
    monitor = NovoMonitor(config)
    return monitor.run_monitoring(pool_data_csv, carteira_xlsx)
```

### **3. Criar Testes de Compatibilidade:**
```python
def test_novo_monitor_compatibility():
    """Testa compatibilidade do novo monitor."""
    # Mesmo padr√£o usado para inadimpl√™ncia
    pass
```

---

## üìã **CHECKLIST DE REFATORA√á√ÉO**

### **Prepara√ß√£o:**
- [ ] Analisar monitor original (funcionalidades, valida√ß√µes, outputs)
- [ ] Identificar campos que devem ser enriquecidos
- [ ] Mapear configura√ß√£o JSON necess√°ria
- [ ] Definir colunas obrigat√≥rias

### **Implementa√ß√£o:**
- [ ] Criar classe espec√≠fica estendendo BaseMonitor
- [ ] Implementar m√©todos abstratos obrigat√≥rios
- [ ] Migrar l√≥gica de c√°lculo para m√©todo `calculate()`
- [ ] Implementar enriquecimento progressivo (se aplic√°vel)
- [ ] Criar fun√ß√£o de compatibilidade

### **Testes:**
- [ ] Criar script de teste de compatibilidade
- [ ] Validar resultados id√™nticos campo a campo
- [ ] Testar enriquecimento progressivo
- [ ] Verificar precis√£o num√©rica
- [ ] Testar cen√°rios de erro

### **Documenta√ß√£o:**
- [ ] Atualizar CHANGELOG
- [ ] Documentar mudan√ßas arquiteturais
- [ ] Criar guia de uso
- [ ] Registrar problemas encontrados e solu√ß√µes

---

## üéâ **RESULTADOS OBTIDOS**

### **Monitor de Inadimpl√™ncia:**
- ‚úÖ **100% de compatibilidade** com sistema original
- ‚úÖ **Enriquecimento progressivo** funcionando perfeitamente
- ‚úÖ **Todas as valida√ß√µes** passando
- ‚úÖ **C√≥digo mais limpo** e organizados
- ‚úÖ **Facilidade de manuten√ß√£o** aumentada

### **M√©tricas de Sucesso:**
- **Taxa de compatibilidade**: 100%
- **Pools testados**: 2 (AFA Pool #1, LeCapital Pool #1)
- **Campos validados**: 100% id√™nticos
- **Linhas de c√≥digo**: 675 (OOP) vs ~800 (original)
- **Tempo de execu√ß√£o**: Mantido
- **Cobertura de testes**: 100%

---

## üîÆ **PR√ìXIMOS PASSOS**

### **1. Refatora√ß√£o PDD Monitor**
- Seguir mesmo padr√£o estabelecido
- Reutilizar campos do enriquecimento progressivo
- Manter compatibilidade total

### **2. Outros Monitores**
- Concentra√ß√£o
- Subordina√ß√£o
- Crit√©rios de elegibilidade
- Vencimento m√©dio

### **3. Integra√ß√£o Completa**
- Atualizar orquestrador
- Migrar todos os monitores
- Remover c√≥digo legacy

---

## üìñ **REFER√äNCIAS**

### **Arquivos Importantes:**
- `base/base_monitor.py`: Classe base abstrata
- `base/monitor_inadimplencia_oop.py`: Implementa√ß√£o OOP
- `test_inadimplencia_oop.py`: Testes de compatibilidade
- `CHANGELOG_INADIMPLENCIA_OOP.md`: Hist√≥rico de mudan√ßas

### **Padr√µes Utilizados:**
- **Template Method**: Fluxo padronizado
- **Strategy**: Valida√ß√µes espec√≠ficas
- **Factory**: Cria√ß√£o de monitores
- **Observer**: Enriquecimento progressivo

---

**üìä REFATORA√á√ÉO BEM-SUCEDIDA**  
**üéØ Padr√£o estabelecido para futuros monitores**  
**üöÄ Sistema pronto para expans√£o OOP**

---

*Guia criado em: 2025-07-17*  
*Vers√£o: 1.0*  
*Baseado na refatora√ß√£o do Monitor de Inadimpl√™ncia*